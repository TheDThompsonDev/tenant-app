generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}


enum Role {
  ADMIN
  APPLICANT
  TENANT
  PROPERTY_MANAGER
  LEASING_AGENT
}

enum LeaseStatus {
  ACTIVE
  EXPIRED
  TERMINATED
}

enum RentalApplicationStatus {
  PENDING
  APPROVED
  DENIED
}

enum NotificationType {
  EMAIL
  SMS
  PUSH
}

enum NotificationStatus {
  SENT
  PENDING
  FAILED
}

enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
}

enum AmenityAvailabilityStatus {
  AVAILABLE
  UNAVAILABLE
}

enum ApartmentAvailabilityStatus {
  AVAILABLE
  UNAVAILABLE
}

model Address {
  id                String             @id @default(uuid())
  number            Int
  street            String
  suiteNumber       Int?
  city              String
  state             String
  zipCode           String
  country           String
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  ManagementCompany ManagementCompany?
  Property          Property?
}


model ContactInfo {
  id          String   @id @default(uuid())
  contactName String
  email       String
  phoneNumber String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}


model User {
  id          String   @id @default(uuid())
  firstName   String   @db.VarChar(40)
  lastName    String   @db.VarChar(40)
  email       String   @unique
  password    String
  dateOfBirth DateTime
  phoneNumber String   @db.VarChar(40)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}


model Admin {
  id        String   @id @default(uuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userRole  String   @default(ADMIN)
}


model PropertyManager {
  id         String   @id @default(uuid())
  userId     String   @unique
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade) // FK to User
  userRole   String   @default(PROPERTY_MANAGER)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Tenant {
  id      String @id @default(uuid())
  userId  String @unique
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  leaseId String @unique
  lease   Lease  @relation(fields: [leaseId], references: [id], onDelete: Cascade)  
  userRole String @default(TENANT)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  notifications Notification[]
  guest      Guest[]
}


model LeasingAgent {
  id         String    @id @default(uuid())
  userId     String    @unique
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userRole   String    @default(LEASING_AGENT)
  propertyId String    @unique
  property   Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
}

model Guest {
  id         String    @id @default(uuid())
  tenant     Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId   String    @unique    
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
}


model ManagementCompany {
  id         String     @id @default(uuid())
  name       String
  address    Address    @relation(fields: [addressId], references: [id])
  addressId  String     @unique
  websiteURL String?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  property   Property[]
}

model Property {
  id                  String              @id @default(uuid())
  managementCompany   ManagementCompany   @relation(fields: [managementCompanyId], references: [id])
  managementCompanyId String              @unique
  address             Address             @relation(fields: [addressId], references: [id])
  addressId           String              @unique
  propertyName        String
  websiteURL          String
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  amenities           PropertyToAmenity[]
  apartments          Apartment[]
  leasingAgent        LeasingAgent[]?
  tenant              Tenant[]
}


model Amenity {
  id                 String              @id @default(uuid())
  amenityName        String
  description        String?
  location           String?
  availabilityStatus DateTime
  requiresAccessCode Boolean             @default(false)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  PropertyToAmenity  PropertyToAmenity[]
}

model PropertyToAmenity {
  id         String   @id @default(uuid())
  property   Property @relation(fields: [propertyId], references: [id])
  propertyId String
  amenity    Amenity  @relation(fields: [amenityId], references: [id])
  amenityId  String
}


model Apartment {
  id          String   @id @default(uuid())
  property    Property @relation(fields: [propertyId], references: [id])
  propertyId  String
  unitNumber  Int
  maxCapacity Int
  squareFeet  Int
  image       String
  bedrooms    Int
  bathrooms   Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}




model RentalApplication {
  id          String                  @id @default(uuid())
  // ERROR FIX: Changed type from String? to match Apartment.id (String) and kept @unique to enforce one-to-one.
  apartmentId String?                 @unique
  status      RentalApplicationStatus
  startDate   DateTime
  length      Int

  // Relation to Apartment (one-to-one)
  apartment Apartment? @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  applicant Applicant?
}



model Applicant {
  id                  String             @id @default(uuid())
  userId              String             @unique
  user                User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  userRole            String
  rentalApplicationId String?            @unique
  rentalApplication   RentalApplication? @relation(fields: [rentalApplicationId], references: [id], onDelete: Cascade)
  addressId           String?
  address             Address?           @relation(fields: [addressId], references: [id], onDelete: Cascade)
  governmentId        String // government_id column from SQL
  socialSecurity      String // social_security column
  vehicles            Int? // vehicles (optional)
  smoker              String
  annualIncome        Float? // annual_income
  pet                 String
  signatureStatus     String // signature_status
}



model Lease {
  id              String      @id @default(uuid())
  // ERROR FIX: Changed type to String to match Apartment.id and kept @unique for one-to-one.
  apartmentId     String      @unique
  apartment       Apartment   @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  leaseStart      DateTime
  leaseEnd        DateTime
  monthlyRent     Decimal
  securityDeposit Decimal
  leaseStatus     LeaseStatus

  tenant Tenant?
}

model Listing {
  id          String    @id @default(uuid())
  // ERROR FIX: Changed type to String to match Apartment.id.
  apartmentId String
  apartment   Apartment @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  listingDate DateTime
  moveInDate  DateTime
  leaseLength Int
  petFriendly Boolean
  furnished   Boolean
  // one-to-many (an apartment can have many listings)
  Property    Property? @relation(fields: [propertyId], references: [id])
  propertyId  String?
}


model Notification {
  id               String               @id @default(uuid()) @map("notification_id")
  tenantId         String
  tenant           Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  propertyId       String?
  notificationType NotificationType
  title            String
  sentAt           DateTime
  message          String
  status           NotificationStatus
  priority         NotificationPriority
}


model ParkingPass {
  id             String    @id @default(uuid())
  // ERROR FIX: Changed type to String to match Apartment.id.
  apartmentId    String
  apartment      Apartment @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  licensePlate   String
  make           String
  model          String
  color          String
  createdAt      DateTime  @default(now())
  expirationDate DateTime
}


model SmartLock {
  id          String    @id @default(uuid())
  apartmentId String    @unique
  apartment   Apartment @relation(fields: [apartmentId], references: [id], onDelete: Cascade)

  // One-to-one with DigitalAccessKey.
  digitalAccessKey DigitalAccessKey?
}


model DigitalAccessKey {
  id             String    @id @default(uuid())
  smartLockId    String    @unique
  smartLock      SmartLock @relation(fields: [smartLockId], references: [id], onDelete: Cascade)
  code           String
  expirationDate DateTime
}



model PackageLocker {
  id                String             @id @default(uuid())
  propertyId        String
  property          Property           @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  lockerNumber      String
  location          String
  lockerStatus      String
  lastAccessedAt    DateTime?
  accessCode        String
  assignedUserId    String?
  packageId         String?
  // One-to-many: A package locker can have multiple logs.
  packageLockerLogs PackageLockerLog[]
}

model PackageLockerLog {
  id              String        @id @default(uuid())
  packageLockerId String
  packageLocker   PackageLocker @relation(fields: [packageLockerId], references: [id], onDelete: Cascade)
  packageId       String?
  assignedUserId  String?
  action          String
  timestamp       DateTime
  performedBy     String
}



